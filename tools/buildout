#!/bin/sh

SAMPLES=184
MAXSCORE=896

if [ -z "$3" ]
then
	MODE=0
else
	MODE=$3
fi

BINDIR=$(dirname $0)

#
# Image conversion for error correcting dither option
#	# for 128x192
#	RESIZE_RESOLUTION="80x120"
#	# for 128x96
#	RESIZE_RESOLUTION="80x60"
#	DITHER_OPTS="-quantize YIQ -dither FloydSteinberg \
#			-map ${BINDIR}/colormap.ppm"
# Image conversion for posterization option
#	DITHER_OPTS="-quantize YIQ +dither \
#			-map ${BINDIR}/colormap.ppm"
# Image conversion for monochrome option
#	DITHER_OPTS="-monochrome"
# Image conversion for ordered dither option (16-colors)
#	DITHER_OPTS="-ordered-dither o8x8,4,4,4"
# Image conversion for ordered dither option (256-colors)
#	DITHER_OPTS="-ordered-dither o8x8,8,8,8"
# Image conversion for ordered dither option (4-colors)
#	DITHER_OPTS="-ordered-dither o2x2,2,2,2"
#
if [ x$MODE == x0 ]
then
	RESOLUTION="128x192"
	RESIZE_OPTS="110x200%!"
	RESIZE_RESOLUTION=$RESOLUTION
	DITHER_OPTS="-ordered-dither o8x8,4,4,4"
elif [ x$MODE == x1 ]
then
	RESOLUTION="128x96"
	RESIZE_OPTS="110x100%!"
	RESIZE_RESOLUTION=$RESOLUTION
	DITHER_OPTS="-ordered-dither o8x8,4,4,4"
elif [ x$MODE == x2 ]
then
	RESOLUTION="128x96"
	RESIZE_OPTS="110x100%!"
	RESIZE_RESOLUTION=$RESOLUTION
	DITHER_OPTS="-ordered-dither o8x8,8,8,8"
elif [ x$MODE == x3 ]
then
	RESOLUTION="128x192"
	RESIZE_OPTS="110x200%!"
	RESIZE_RESOLUTION=$RESOLUTION
	DITHER_OPTS="+dither -colors 2 -colorspace gray -normalize"
elif [ x$MODE == x4 ]
then
	RESOLUTION="256x192"
	RESIZE_OPTS="110x100%!"
	RESIZE_RESOLUTION=$RESOLUTION
	DITHER_OPTS="+dither -colors 2 -colorspace gray -normalize"
elif [ x$MODE == x5 ]
then
	RESOLUTION="128x96"
	RESIZE_OPTS="110x100%!"
	RESIZE_RESOLUTION=$RESOLUTION
	DITHER_OPTS="-quantize YIQ +dither \
			-map ${BINDIR}/colormap4s0.ppm"
elif [ x$MODE == x6 ]
then
	RESOLUTION="128x96"
	RESIZE_OPTS="110x100%!"
	RESIZE_RESOLUTION=$RESOLUTION
	DITHER_OPTS="-quantize YIQ +dither \
			-map ${BINDIR}/colormap4s1.ppm"
elif [ x$MODE == x7 ]
then
	RESOLUTION="128x96"
	RESIZE_OPTS="110x100%!"
	RESIZE_RESOLUTION=$RESOLUTION
	DITHER_OPTS="-quantize YIQ +dither \
			-map ${BINDIR}/colormap4a.ppm"
else
	echo "Unknown video mode ${MODE}!"
	exit 1
fi

PPM2FRM=${BINDIR}/ppm2frm${MODE}
FRM2RAW=${BINDIR}/frm2raw${MODE}
WATCHOUT=${BINDIR}/watchout

PPMBASE=../ppm/"$2"
RAWBASE=../raw/"$2"
PCMBASE=../pcm/"$2"

cleanup()
{
	rm -f buildout.$$

	rm -f ../mov/"$2".mov
	rm -f ../mov/"$2".wav

	rm -rf $PPMBASE
	rm -rf $RAWBASE
	rm -rf $PCMBASE

	exit 0
}

# START HERE

trap "cleanup \"$1\" \"$2\"" 1 2 3 15

mkdir -p $PPMBASE
mkdir -p $RAWBASE
mkdir -p $PCMBASE

echo Transcoding $(basename "$1")...
ffmpeg -i "$1" -r 60 -b 200000 -f mov -y ../mov/"$2".mov
ffmpeg -i ../mov/"$2".mov -vn -ac 1 -acodec pcm_u8 -y ../mov/"$2".wav
echo Preparing audio data...
sox ../mov/"$2".wav -t raw -r 22050 - norm lowpass 5000 2>/dev/null | \
	sox -t raw -r 22050 -b 8 -c 1 -e unsigned - -t raw - rate 11040 2>/dev/null | \
	split -d -b $SAMPLES -a 10 - ${PCMBASE}/"$2". 2>/dev/null

CURRAW=${RAWBASE}/current.raw
TMPRAW=${RAWBASE}/tmp.raw

# Start with all-black frame...
cp ${BINDIR}/BLACK.raw $CURRAW

echo Building final output file...

$WATCHOUT "$2" $MODE &

cat ${BINDIR}/START.frm > "$2".out
dd if=/dev/zero bs=$SAMPLES count=1 2>/dev/null >> "$2".out

mkfifo buildout.$$

# should use ffmpeg to determing video length, for now use 4 hour max
for start in $(seq 0 10 14400)
do
# divide movie into 10 second chunks to decrease disk usage during conversion

	cd $PPMBASE
	rm -f *
	ffmpeg -ss $start -vframes 600 \
		-i ../../mov/"$2".mov %d.ppm >/dev/null 2>&1
	cd - >/dev/null

	for i in $(seq 1 600)
	do
		PPM=${PPMBASE}/$i.ppm
		PCM=${PCMBASE}/"$2".$(printf "%010d" $((($start * 60) + $i)))

		if [ ! -f $PPM ]
		then
			break
		fi

		if [ $i -eq 1 ]
		then
			echo Processing frame $((($start * 60) + ${i}))... \
				\($(date)\) >&2
		fi

		$FRM2RAW $CURRAW buildout.$$ $TMPRAW &
		CURUPDATE=$!
		convert -resize ${RESIZE_OPTS} -resize ${RESIZE_RESOLUTION} \
				${DITHER_OPTS} \
				-gravity center -extent ${RESOLUTION} \
				-background black \
				$PPM ppm:- | \
			$PPM2FRM - $CURRAW $MAXSCORE - | \
			tee buildout.$$
		wait $CURUPDATE
		mv $TMPRAW $CURRAW
		if [ -f $PCM ]
		then
			cat $PCM
			PCMSIZE=$(stat -c '%s' $PCM)
			if [ $PCMSIZE -lt $SAMPLES ]
			then
				dd if=/dev/zero bs=$(($SAMPLES - $PCMSIZE)) \
					count=1 2>/dev/null
			fi
		else
			# This actually holds DAC at lowest value...
			# ...should output 0x80 instead?
			dd if=/dev/zero bs=$SAMPLES count=1 2>/dev/null
		fi
	done >> "$2".out

done

echo Done!

cleanup "$1" "$2"
