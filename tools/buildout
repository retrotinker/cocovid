#!/bin/sh

FRAMESTEP=1
SAMPLES=736

MAXSCORE=960

NICE=2

BINDIR=$(dirname $0)

PPM2RAW=${BINDIR}/ppm2raw
RAW2DRW=${BINDIR}/raw2drw
DRW2DRL=${BINDIR}/drw2drl
DRLPRUNE=${BINDIR}/drlprune
DRL2RAW=${BINDIR}/drl2raw
WATCHOUT=${BINDIR}/watchout

PPMBASE=../ppm/"$2"
RAWBASE=../raw/"$2"
PCMBASE=../pcm/"$2"

cleanup()
{
	rm -f buildout.$$

	rm -f ../mov/"$2".mov
	rm -f ../mov/"$2".wav

	rm -rf $PPMBASE
	rm -rf $RAWBASE
	rm -rf $PCMBASE

	exit 0
}

# START HERE

trap "cleanup \"$1\" \"$2\"" 1 2 3 15

mkdir -p $PPMBASE
mkdir -p $RAWBASE
mkdir -p $PCMBASE

echo Transcoding $(basename "$1")...
nice -n $NICE ffmpeg -i "$1" -r 15 -ar 11040 -ac 1 -b 200000 -acodec pcm_u8 \
	-f mov -y ../mov/"$2".mov
nice -n $NICE ffmpeg -i ../mov/"$2".mov -vn -acodec pcm_u8 -y ../mov/"$2".wav
nice -n $NICE normalize ../mov/"$2".wav

echo Converting .mov file to a sequence of .ppm files...
cd $PPMBASE
nice -n $NICE ffmpeg -i ../../mov/"$2".mov %d.ppm >/dev/null 2>&1
FRAMES=$(ls | wc -l)
cd - >/dev/null

echo Converting .wav file to .pcm file and split into appropriately sized chunks...
cd $PCMBASE
dd if=../../mov/"$2".wav bs=44 skip=1 2>/dev/null | \
	nice -n $NICE split -d -b $SAMPLES -a 10 - "$2".
cd - >/dev/null

CURRAW=${RAWBASE}/current.raw
TMPRAW=${RAWBASE}/tmp.raw

# Start with all-black frame...
cp ${BINDIR}/BLACK.raw $CURRAW

echo Building final output file...

$WATCHOUT "$2" &

cat ${BINDIR}/BLACK.drl > "$2".out
dd if=/dev/zero bs=$SAMPLES count=1 2>/dev/null >> "$2".out

mkfifo buildout.$$

for i in $(seq 1 $FRAMESTEP $FRAMES)
do
	if [ $(($i % $((10 * 15)))) -eq 1 ]
	then
		echo Processing frame ${i}... >&2
	fi
	PPM=${PPMBASE}/$i.ppm
	DRL=${DRLBASE}/${i}.drl
	PCM=${PCMBASE}/"$2".$(printf "%010d" $(($i / $FRAMESTEP)))

	$DRL2RAW $CURRAW buildout.$$ $TMPRAW &
	CURUPDATE=$!
	convert -resize 110x100%! -resize 256x192 \
			-ordered-dither o2x2,3,3,3 \
			-quantize YIQ +dither -map ${BINDIR}/colormap.ppm \
			-background black -gravity center -extent 256x192 \
			$PPM ppm:- | \
		$PPM2RAW - -|\
		$RAW2DRW $CURRAW - - | \
		$DRW2DRL - - | \
		$DRLPRUNE $CURRAW - - $MAXSCORE | \
		tee buildout.$$
	wait $CURUPDATE
	mv $TMPRAW $CURRAW
	if [ -f $PCM ]
	then
		cat $PCM
		PCMSIZE=$(stat -c '%s' $PCM)
		if [ $PCMSIZE -lt $SAMPLES ]
		then
			dd if=/dev/zero bs=$(($SAMPLES - $PCMSIZE)) \
				count=1 2>/dev/null
		fi
	else
		# This actually holds DAC at lowest value...
		# ...should output 0x88 ("CoCo Law" virtual zero) instead?
		dd if=/dev/zero bs=$SAMPLES count=1 2>/dev/null
	fi
done >> "$2".out

echo Done!

cleanup "$1" "$2"
