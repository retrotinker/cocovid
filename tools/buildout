#!/bin/sh

SAMPLES=184

MAXSCORE=832

NICE=2

BINDIR=$(dirname $0)

PPM2FRM=${BINDIR}/ppm2frm
FRM2RAW=${BINDIR}/frm2raw
WATCHOUT=${BINDIR}/watchout

PPMBASE=../ppm/"$2"
RAWBASE=../raw/"$2"
PCMBASE=../pcm/"$2"

cleanup()
{
	rm -f buildout.$$

	rm -f ../mov/"$2".mov
	rm -f ../mov/"$2".wav

	rm -rf $PPMBASE
	rm -rf $RAWBASE
	rm -rf $PCMBASE

	exit 0
}

# START HERE

trap "cleanup \"$1\" \"$2\"" 1 2 3 15

mkdir -p $PPMBASE
mkdir -p $RAWBASE
mkdir -p $PCMBASE

echo Transcoding $(basename "$1")...
nice -n $NICE ffmpeg -i "$1" -r 60 -ar 11040 -ac 1 -b 200000 -acodec pcm_u8 \
	-f mov -y ../mov/"$2".mov
nice -n $NICE ffmpeg -i ../mov/"$2".mov -vn -acodec pcm_u8 -y ../mov/"$2".wav
nice -n $NICE normalize -a 0.7 ../mov/"$2".wav

echo Converting .wav file to .pcm file and split into appropriately sized chunks...
cd $PCMBASE
dd if=../../mov/"$2".wav bs=44 skip=1 2>/dev/null | \
	nice -n $NICE split -d -b $SAMPLES -a 10 - "$2".
cd - >/dev/null

CURRAW=${RAWBASE}/current.raw
TMPRAW=${RAWBASE}/tmp.raw

# Start with all-black frame...
cp ${BINDIR}/BLACK.raw $CURRAW

echo Building final output file...

$WATCHOUT "$2" &

cat ${BINDIR}/START.frm > "$2".out
dd if=/dev/zero bs=$SAMPLES count=1 2>/dev/null >> "$2".out

mkfifo buildout.$$

# should use ffmpeg to determing video length, for now use 4 hour max
for start in $(seq 0 10 14400)
do
# divide movie into 10 second chunks to decrease disk usage during conversion

	cd $PPMBASE
	rm -f *
	nice -n $NICE ffmpeg -ss $start -vframes 600 \
		-i ../../mov/"$2".mov %d.ppm >/dev/null 2>&1
	cd - >/dev/null

	for i in $(seq 1 600)
	do
		PPM=${PPMBASE}/$i.ppm
		PCM=${PCMBASE}/"$2".$(printf "%010d" $((($start * 60) + $i)))

		if [ ! -f $PPM ]
		then
			break
		fi

		if [ $i -eq 1 ]
		then
			echo Processing frame $((($start * 60) + ${i}))... \
				\($(date)\) >&2
		fi

		$FRM2RAW $CURRAW buildout.$$ $TMPRAW &
		CURUPDATE=$!
# Image conversion for error correcting dither option
#		convert -resize 110x200%! -resize 80x120 \
#				-quantize YIQ -dither FloydSteinberg \
#				-map ${BINDIR}/colormap.ppm \
#				-gravity center -extent 128x192 \
#				-background black \
#				$PPM ppm:- | \
# Image conversion for posterization option
#		convert -resize 110x200%! -resize 128x192 \
#				-quantize YIQ +dither \
#				-map ${BINDIR}/colormap.ppm \
#				-gravity center -extent 128x192 \
#				-background black \
#				$PPM ppm:- | \
# Image conversion for monochrome option
#		convert -resize 110x200%! -resize 128x192 \
#				-channel All -random-threshold 30x80% \
#				-gravity center -extent 128x192 \
#				-background black \
#				$PPM ppm:- | \
# Image conversion for ordered dither option
		convert -resize 110x200%! -resize 128x192 \
				-ordered-dither o8x8,4,4,4 \
				-gravity center -extent 128x192 \
				-background black \
				$PPM ppm:- | \
			$PPM2FRM - $CURRAW $MAXSCORE - | \
			tee buildout.$$
		wait $CURUPDATE
		mv $TMPRAW $CURRAW
		if [ -f $PCM ]
		then
			cat $PCM
			PCMSIZE=$(stat -c '%s' $PCM)
			if [ $PCMSIZE -lt $SAMPLES ]
			then
				dd if=/dev/zero bs=$(($SAMPLES - $PCMSIZE)) \
					count=1 2>/dev/null
			fi
		else
			# This actually holds DAC at lowest value...
			# ...should output 0x80 instead?
			dd if=/dev/zero bs=$SAMPLES count=1 2>/dev/null
		fi
	done >> "$2".out

done

echo Done!

cleanup "$1" "$2"
