#!/bin/sh

PPM=1
RAW=1
PCM=1

FRAMESTEP=2
SAMPLES=735
PCMFACTOR=1

#MAXSCORE=896
MAXSCORE=640

BINDIR=$(dirname $0)

MOV2PPM=${BINDIR}/mov2ppm
PPM2RAW=${BINDIR}/ppm2raw
RAW2RLE=${BINDIR}/raw2rle
RAW2DRW=${BINDIR}/raw2drw
DRW2DRL=${BINDIR}/drw2drl
DRL2RAW=${BINDIR}/drl2raw
WAV2PCM=${BINDIR}/wav2pcm
SPLITPCM=${BINDIR}/splitpcm
DRLPRUNE=${BINDIR}/drlprune

RAWBASE=../raw/"$1"
DRWBASE=../drw/"$1"
DRLBASE=../drl/"$1"
PCMBASE=../pcm/"$1"

mkdir -p $RAWBASE
mkdir -p $DRWBASE
mkdir -p $DRLBASE
mkdir -p $PCMBASE

if [ $PPM -ne 0 ]
then
	echo Converting .mov file to a sequence of .ppm files...
	mkdir -p ../ppm/"$1"
	cd ../ppm/"$1"
	rm -f *
	$MOV2PPM ../../mov/"$1".mov >/dev/null 2>&1
	FRAMES=$(ls | wc -l)
	cd - >/dev/null
else
	cd ../ppm/"$1"
	FRAMES=$(ls | wc -l)
	cd - >/dev/null
fi

if [ $RAW -ne 0 ]
then
	echo Converting .ppm files to .raw files...
	mkdir -p ../raw/"$1"
	rm -f ../raw/"$1"/*
	cd ../ppm/"$1"
	for i in *
	do
	#convert -map ${BINDIR}/colormap.ppm -dither Riemersma $i tmp-$$.ppm
	# 100x100% is placeholder for when we rely on convert for stretching
	convert -resize 100x100%! -resize 256x192 \
		-background black -gravity center -extent 256x192 \
		-ordered-dither o2x2,4,4,4 \
		-quantize YIQ +dither -map ${BINDIR}/colormap.ppm \
		$i tmp-$$.ppm
	$PPM2RAW tmp-$$.ppm ../../raw/"$1"/${i%ppm}raw
	rm $i
	done
	rm tmp-$$.ppm
	cd - >/dev/null
fi

if [ $PCM -ne 0 ]
then
	echo Converting .wav file to .pcm file and split into appropriately sized chunks...
	mkdir -p ../pcm/"$1"
	cd ../pcm/"$1"
	rm -f *
	$WAV2PCM ../../mov/"$1".wav "$1".pcm $PCMFACTOR
	$SPLITPCM "$1".pcm "$1". $SAMPLES 2>/dev/null
	cd - >/dev/null
fi

CURRAW=${RAWBASE}/current.raw
TMPRAW=${RAWBASE}/tmp.raw

# Start with all-black frame...
cp ${BINDIR}/BLACK.raw $CURRAW

echo Building final output file...

cat ${BINDIR}/BLACK.drl > "$2"
dd if=/dev/zero bs=$SAMPLES count=1 2>/dev/null >> "$2"

for i in $(seq 1 $FRAMESTEP $FRAMES)
do
	if [ $(($i % $((10 * 30)))) -eq 1 ]
	then
		echo Processing frame ${i}... >&2
	fi
	RAW=${RAWBASE}/$i.raw
	DRW=${DRWBASE}/${i}-cur.drw
	DRL=${DRLBASE}/${i}-cur.drl
	DRLOUT=${DRLBASE}/${i}-out.drl
	PCMFILE=${PCMBASE}/*.$((${i}/$FRAMESTEP))

	$RAW2DRW $CURRAW $RAW $DRW
	rm $RAW
	$DRW2DRL $DRW $DRL
	rm $DRW
	$DRLPRUNE $CURRAW $DRL $DRLOUT $MAXSCORE
	rm $DRL
	cat $DRLOUT
	$DRL2RAW $CURRAW $DRLOUT $TMPRAW
	rm $DRLOUT
	mv $TMPRAW $CURRAW
	if [ -f $PCMFILE ]
	then
		cat $PCMFILE
		PCMSIZE=$(stat -c '%s' $PCMFILE)
		if [ $PCMSIZE -lt $SAMPLES ]
		then
			dd if=/dev/zero bs=$(($SAMPLES - $PCMSIZE)) count=1 2>/dev/null
		fi
		rm $PCMFILE
	else
		# This actually holds DAC at lowest value...
		# ...should output 0x88 ("CoCo Law" virtual zero) instead?
		dd if=/dev/zero bs=$SAMPLES count=1 2>/dev/null
	fi
done >> "$2"

rm -rf $RAWBASE
rm -rf $DRWBASE
rm -rf $DRLBASE
rm -rf $PCMBASE

echo Done!
