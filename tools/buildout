#!/bin/sh

SAMPLES=184

MODE=$3

if [ -z "$4" ]
then
	MAXSCORE=832
else
	MAXSCORE=$4
fi

BINDIR=$(dirname $0)

#
# Image conversion for error correcting dither option
#	# for 128x192
#	RESIZE_RESOLUTION="80x120"
#	# for 128x96
#	RESIZE_RESOLUTION="80x60"
#	DITHER_OPTS="-quantize YIQ -dither FloydSteinberg \
#			-map ${BINDIR}/colormap.ppm"
# Image conversion for posterization option
#	DITHER_OPTS="-quantize YIQ +dither \
#			-map ${BINDIR}/colormap.ppm"
# Image conversion for monochrome option
#	DITHER_OPTS="-monochrome"
# Image conversion for ordered dither option (4- or 16-colors)
#	DITHER_OPTS="-ordered-dither o8x8,4,4,4"
# Image conversion for ordered dither option (256-colors)
#	DITHER_OPTS="-ordered-dither o8x8,8,8,8"
#
if [ x$MODE == x0 ]
then
	RESOLUTION="128x192"
	RESIZE_OPTS="110x200%!"
	RESIZE_RESOLUTION=$RESOLUTION
	DITHER_OPTS="-ordered-dither o8x8,4,4,4"
elif [ x$MODE == x1 ]
then
	RESOLUTION="128x96"
	RESIZE_OPTS="110x100%!"
	RESIZE_RESOLUTION=$RESOLUTION
	DITHER_OPTS="-ordered-dither o8x8,4,4,4"
elif [ x$MODE == x2 ]
then
	RESOLUTION="128x96"
	RESIZE_OPTS="110x100%!"
	RESIZE_RESOLUTION=$RESOLUTION
	DITHER_OPTS="-ordered-dither o8x8,8,8,8"
elif [ x$MODE == x3 ]
then
	RESOLUTION="128x192"
	RESIZE_OPTS="110x200%!"
	RESIZE_RESOLUTION=$RESOLUTION
	DITHER_OPTS="+dither -colors 2 -colorspace gray -normalize"
elif [ x$MODE == x4 ]
then
	RESOLUTION="256x192"
	RESIZE_OPTS="110x100%!"
	RESIZE_RESOLUTION=$RESOLUTION
	DITHER_OPTS="+dither -colors 2 -colorspace gray -normalize"
elif [ x$MODE == x5 ]
then
	RESOLUTION="128x96"
	RESIZE_OPTS="110x100%!"
	RESIZE_RESOLUTION=$RESOLUTION
	DITHER_OPTS="-ordered-dither o8x8,4,4,4"
elif [ x$MODE == x6 ]
then
	RESOLUTION="128x96"
	RESIZE_OPTS="110x100%!"
	RESIZE_RESOLUTION=$RESOLUTION
	DITHER_OPTS="-ordered-dither o8x8,4,4,4"
elif [ x$MODE == x7 ]
then
	RESOLUTION="128x192"
	RESIZE_OPTS="110x200%!"
	RESIZE_RESOLUTION=$RESOLUTION
	DITHER_OPTS="-ordered-dither o8x8,4,4,4"
else
	echo "Unknown video mode ${MODE}!"
	exit 1
fi

PPM2FRM=${BINDIR}/ppm2frm${MODE}
FRM2RAW=${BINDIR}/frm2raw${MODE}
WATCHOUT=${BINDIR}/watchout

TMPDIR=$(mktemp -d)

cleanup()
{
	rm -rf $TMPDIR

	exit 0
}

# START HERE

trap "cleanup \"$1\" \"$2\"" 1 2 3 15

echo Transcoding $(basename "$1")...
ffmpeg -i "$1" -r 60 -b 200000 -ac 1 -acodec pcm_u8 -f mov \
	-y ${TMPDIR}/"$2".mov 2>/dev/null
ffmpeg -i ${TMPDIR}/"$2".mov -vn -ac 1 -acodec pcm_u8 \
	-y ${TMPDIR}/"$2".wav 2>/dev/null
echo Preparing audio data...
sox ${TMPDIR}/"$2".wav -t raw -r 22050 - -D norm lowpass 5000 2>/dev/null | \
	sox -t raw -r 22050 -b 8 -c 1 -e unsigned - -t raw - -D \
		rate 11040 2>/dev/null | \
	split -d -b $SAMPLES -a 10 - ${TMPDIR}/"$2"-pcm. 2>/dev/null

CURRAW=${TMPDIR}/current.raw
TMPRAW=${TMPDIR}/tmp.raw

# Start with all-black frame...
cp ${BINDIR}/BLACK.raw $CURRAW

echo Building final output file...

$WATCHOUT $MODE $TMPDIR &

cat ${BINDIR}/START.frm > "$2".out
dd if=/dev/zero bs=$SAMPLES count=1 2>/dev/null >> "$2".out

mkfifo ${TMPDIR}/buildout.$$

# should use ffmpeg to determing video length, for now use 4 hour max
for start in $(seq 0 10 14400)
do
# divide movie into 10 second chunks to decrease disk usage during conversion

	cd $TMPDIR
	rm -f *.ppm
	ffmpeg -ss $start -vframes 600 \
		-i "$2".mov %d.ppm >/dev/null 2>&1
	cd - >/dev/null

	for i in $(seq 1 600)
	do
		PPM=${TMPDIR}/$i.ppm
		PCM=${TMPDIR}/"$2"-pcm.$(printf "%010d" $((($start * 60) + $i)))

		if [ ! -f $PPM ]
		then
			break
		fi

		if [ $i -eq 1 ]
		then
			echo Processing frame $((($start * 60) + ${i}))... \
				\($(date)\) >&2
		fi

		$FRM2RAW $CURRAW ${TMPDIR}/buildout.$$ $TMPRAW &
		CURUPDATE=$!
		convert -resize ${RESIZE_OPTS} -resize ${RESIZE_RESOLUTION} \
				${DITHER_OPTS} \
				-gravity center -extent ${RESOLUTION} \
				-background black \
				$PPM ppm:- | \
			$PPM2FRM - $CURRAW $MAXSCORE - | \
			tee ${TMPDIR}/buildout.$$
		wait $CURUPDATE
		mv $TMPRAW $CURRAW
		if [ -f $PCM ]
		then
			cat $PCM
			PCMSIZE=$(stat -c '%s' $PCM)
			if [ $PCMSIZE -lt $SAMPLES ]
			then
				dd if=/dev/zero bs=$(($SAMPLES - $PCMSIZE)) \
					count=1 2>/dev/null
			fi
		else
			# This actually holds DAC at lowest value...
			# ...should output 0x80 instead?
			dd if=/dev/zero bs=$SAMPLES count=1 2>/dev/null
		fi
	done >> "$2".out

done

echo Done!

cleanup "$1" "$2"
